# 데이터 통합
## 데이터 준비 및 통합
    1. 샘플 데이터셋의 이해

    customers, orders, order_details, shipping, satisfaction 데이터프레임의 역할

    각 데이터셋이 포함하는 주요 정보 (예: 고객 ID, 주문 번호, 상품명 등)

    1-2. 데이터프레임 병합 (Merging) 실습

    pd.merge() 함수를 사용한 여러 테이블 결합

    핵심 개념: on 파라미터로 결합 기준('주문번호', '고객ID') 지정하기

    how 파라미터의 중요성 ('inner', 'left')

    1-3. 새로운 컬럼 생성 및 데이터 전처리

    order_details에서 '총금액' 계산 (수량 * 가격 * (1-할인율))

    orders에 주문별 총합 금액 ('총금액') 추가

    timedelta를 활용한 '배송소요일' 계산 및 변환

    2. 핵심 비즈니스 분석
    2-1. 고객 행동 분석

    groupby()와 agg()를 활용한 연령대 및 성별별 주문 통계 분석

    결과 해석: 어떤 연령대/성별 그룹이 총 주문 금액, 평균 주문 금액이 높은가?

    matplotlib과 seaborn을 이용한 시각화 (barplot)

    2-2. 결제 및 배송 채널 분석

    결제 방법별 평균 주문 금액, 총합, 주문 건수 비교

    결과 해석: 어떤 결제 방법이 주로 사용되며, 고액 결제와 연관이 있는가?

    지역별 선호 배송사 분석 (groupby().size().unstack())

    2-3. 고객 만족도 분석

    만족도('만족도')와 평균 주문 금액의 관계

    결과 해석: 만족도가 높은 고객들이 더 많은 금액을 지출하는 경향이 있는가?

    3. 데이터 분석의 결론 및 시사점
    3-1. 주요 발견 요약

    예시: 40대 남성 그룹의 높은 평균 주문 금액

    예시: '간편결제'의 높은 평균 주문 금액

    예시: 특정 지역에서 선호되는 특정 배송사

    3-2. 비즈니스 적용 방안

    데이터 분석 결과를 실제 마케팅이나 운영 전략에 어떻게 활용할 수 있는가?

    (예: 40대 남성 타겟 마케팅 강화, 배송 만족도 개선 방안 등)

* 몰랐던 코드 
```python
order_details[order_details.duplicated(subset=['주문번호'])].sort_values('주문번호')# T/F 로 분리됩
order_details[order_details.duplicated(subset=['주문번호', keep=False])].sort_values('주문번호') #keep은 중복된 아이들을 모두 False 로 나오게 한다. 
옵션 값
#keep 의 역할 
# pandas에서 keep은 주로 중복값을 제거하거나 처리할 때, 어떤 값을 남길지 결정하는 옵션
# 'first' (기본값)
# 중복 중 첫 번째 값만 남기고 나머지는 제거
# 'last'
# 중복 중 마지막 값만 남기고 나머지는 제거
# False
# 모든 중복값 제거 (한 개도 남기지 않음)
#pandas에서 subset은 말 그대로 **“부분집합”**이라는 뜻으로, 특정 열(column)만 선택해서 작업하고 싶을 때 사용하는 옵션, 주로 중복제거, 결측치 제거에서 어떤 열만 기준으로 판단할지 지정할 때 사용  

# 배송정보 추가
full_orders = orders_customers.merge(shipping, on='주문번호') 
#on과 inner의차이 
#on 은 병합할 기준열을 지정하고 inner는 공통 키만 병합한다.
```
## 이상치 삭제
```python

#(함수정의)
def remove_outlier_iqr(data: pd.DataFrame, col: str)-> pd.DataFrame: #매개 변수에 타입을 정해 놓으면 편하다 
    Q1 = data[col].quantile(0.25)
    Q3 = data[col].quantile() #quantile의미 
    IQR =Q3-Q1
    lower_bound = Q1 - (1.5*IQR)
    upper_bonud = Q3 + (1.5 *IQR)
    mask = (data[col] >= lower_bound) & (data[col]<=upper_bonud)
    #return data[mask] #조건을 만족하는 DAtaFrame 은 반환한다. 필터링 결과를 
```
## 이상치 변환 
*z-score 3.0  표준점수가 2라면 
* 윈저 변환 
윈저화란 극단적인 이상치를 다루기 위한 통계 기법으로 , 데이터의 극단값을  특정 분위수 값으로 대체하는 방법이다.  
- 평균에 큰 영향을 주는 이상치를 줄여 분석의 안정성 확보 

```python
def winsorize_outliers(data:pd.DataFrame,col, lower=5, upper=95):
    """윈저화:극값을 특정 백분위 값으로 대체"""
    lower_bound = data[col].quantile(lower /100)
    upper_bonud = data[col].quantile(upper /100)

    data_winsorized = data.copy()
    #clip:lower 보다 작은 수를 다 인자로 바꾸고 upper 보다 큰 수도 모두 인자로 바꾼다.
    #return data_winsorized[col].clip(lower=lower_bound,upper=upper_bonud)
    data_winsorized[col]= data_winsorized[col].clip(lower=lower_bound,upper=upper_bonud)
    return data_winsorized
```
* clip 함수: 값을 지정한 범위 안으로 자르는 함수 

```python 
#titanic에서 객실 등급별로 이상치 분석하기 
#객실 등급을 고려한 이상치 분석 
#객실 등급별로  요금 이상치 탐지(전체 기준 이상치가 객실별로는 이상치 아닐 수 있음)
def detect_outliers_by_group(data: pd.DataFrame, group_col:str, value_col:str):
    """그룹별 이상치 탐지"""
    #먼저, 전원 모두 이상치가 아닌 경우 False 로 세팅 
    outliers =pd.Series(False,data.index) #빈시리즈 생성, 각 행이 이상치인지 기록할 이상치 판별 목록 
    #현재 group_col 기준 유니크한 데이터(pclass -> 1,2,3)
    for group in data[group_col].unique():
        group_data= data[data[group_col]==group][value_col] #group 값에 일치하는 행들만 필터링해서 부분 데이터 프레임을 만든다. 
        #해당 부분데이터프레임에서 이상치를 찾을 값 열만 선택하여 group data 변수에 저장한다.
        Q1 = group_data.quantile(0.25)        
        Q3 = group_data.quantile(0.75)
        IQR = Q3 - Q1
        lower = Q1 - 1.5 * IQR
        upper = Q3 + 1.5 * IQR
        group_outliers = (group_data < lower) | (group_data > upper)
        outliers[group_data.index] = group_outliers #현재 그룹에 해당하는 인덱스 위치만 group_outlier에 덮어쓴다.


    return outliers

    #겍실 등급별 이상한 사람들 (T/F mask series)
fare_outliers_by_pclass = detect_outliers_by_group(tp, 'pclass', 'fare') # tp 데이터프레임에서 ‘pclass’별로 ‘fare’ 열의 이상치를 찾아서, 그 결과를 fare_outliers_by_pclass에 저장
# 각 등급별로 따로 선별한 이상치 개수 
fare_outliers_by_pclass.sum()

## ** 이방법은 
## 1. 직접 for 문으로 그룹을 나눠서 이상치를 계산했고, 2. 이상치 여부를 저장할 Series 를 만들어서 해당 인덱스에 직접 할당했음. 
```
```PYTHON
#객실 등급 이상치 분석 방법 2

## *** 차이점은 groupby + transform() 을 활용한 벡터화된 처리 방식 
def detect_outlier_iqr(data_series):
    Q1 = data_series.quantile(0.25)
    Q3 = data_series.quantile(0.75)
    IQR = Q3 - Q1

    lower_bound = Q1 - (1.5*IQR)
    upper_bound = Q3 + (1.5*IQR)
    return (data_series < lower_bound) | (data_series > upper_bound)

outlier_mask = titanic.groupby('pclass')['fare'].transform(detect_outlier_iqr)
```
위의 예제에서 방법 1과 같이 그룹을 나눠서 이상치를 계산한 이유는 다음과 같다. 
* 각 그룹은 ' 기준분포' 가 다르기 때문 
타이타닉 데이터의 fare(요금)은 pclass(객실 등급)마다 평균과 분산이 완전히 다름.
	•	1등석 요금: 평균이 높고, 고급 승객이라 분산도 큼
	•	3등석 요금: 평균이 낮고, 대부분 비슷한 요금대
    만약 전체 데이터를 한꺼번에 놓고 IQR 기준 이상치를 계산하면…
	•	3등석에서는 대부분 정상인데도, 요금이 조금만 높으면 이상치로 오탐지
	•	1등석에서는 너무 높은 요금도 정상으로 간주될 위험




